---
title: # 
output:
  html_notebook:
    df_print: paged
    geometry: margin=1.25in
    font-family: "Times New Roman"
    color: DarkBlack;
---


## Note:- "This is a R notebook, can be reproduced to find Gene of interest in known/unknown species using trnascriptome data"
<style type="text/css">

body{ /* Normal  */
      font-size: 14px;
      font-family: "Times New Roman";
      color: DarkBlack;
  }
td {  /* Table  */
  font-size: 8px;
}
h1 {
  font-size: 16px;
  color: DarkBlack;
  font-family: "Times New Roman";
  font-weight:bold;
}

h2 {
  font-size: 14px;
  color: DarkBlack;
  font-family: "Times New Roman";
}
code.r{
  font-size: 16px;
  font-family: "Times New Roman";
  
}
pre {
  font-size: 14px
  font-family: "Times New Roman";
}

.tiny {
  font-size: 50%;
  font-family: "Times New Roman";
}
font-family: "Times New Roman";
</style>
```{r setup, include=FALSE,}
knitr::opts_chunk$set(echo = TRUE)
```


<br/><br/>

# &nbsp;&nbsp;&nbsp;&nbsp; 3.1 Setting computational environment.

- Ubuntu operating system and R programmming language were used to setup the computaional environment.

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Setting Ubuntu environment for processing the transcriptome data.
```{r,size="tiny"}
system('uname -a')
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Following tools and libraries were used to setup the The environment. 

```{r,eval=FALSE}
 
sudo nano /etc/environment 
sudo apt-get update
sudo nano /etc/environment 
sudo apt-get r-base
sudo apt-get install r-base
system('sudo apt-get install bedtools')
sudo apt-get install r-base
sudo apt-get install libopenblas-base r-base
wget https://download1.rstudio.org/desktop/bionic/amd64/rstudio-1.2.1335-amd64.deb
sudo gdebi rstudio-xenial-1.1.379-amd64.deb
sudo apt-get install gdebi
 sudo gdebi rstudio-xenial-1.1.379-amd64.deb
sudo gdebi rstudio-1.2.1335-amd64.deb
./rstudio-1.2.1335-amd64.deb
sudo gdebi rstudio-1.2.1335-amd64.deb.1 
sudo apt-get install python3-pip
sudo apt-get install libfreetype6-dev
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Setting R environment

```{r,eval=FALSE}
Sys.setenv(HTTP_PROXY = "10.118.113.5:3128")
Sys.setenv(HTTPS_PROXY = "10.118.113.5:3128")
Sys.setenv(FTP_PROXY = "10.118.113.5:3128")
setwd("~/src/")
system('sudo chmod -R 777 /home/bif/src/')
system('sudo apt-get install pigz')
system('sudo apt install python-cutadapt')
system('pip3 install cutadapt==2.4')
```

```{r,eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("ballgown")
BiocManager::install("genefilter")
BiocManager::install("devtools")
devtools::install_github('alyssafrazee/RSkittleBrewer')
BiocManager::install("rtracklayer")
install.packages('dplyr',dependencies = T)
BiocManager::install("msa")
BiocManager::install("seqinr")
install.packages('ape')
install.packages('rphast')
install.packages('perm')
install.packages("sysfonts")
BiocManager::install('GenomicFeatures')
```
# &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Load required packages

```{r,size='tiny'}
library(rtracklayer)
library(ballgown)
library(RSkittleBrewer)
library(genefilter)
library(dplyr)
library(msa)
library(Biostrings)
library(seqinr)
library(ape)
library(rphast)
library(GenomicFeatures)
library(perm)
```

# &nbsp;&nbsp;&nbsp;&nbsp; 3.2 Load and download experiment data.
- European Nucleotide Archive (ENA)(https://www.ebi.ac.uk/ena) is a biological database that provides a public repository for DNA sequencing data, especially the "short reads" generated by high-throughput sequencing. Raw sequencing reads of *Glycine max* transcriptome for different sttress conition were collected from ENA.
- PhenoData(Data which have expermental information like name ans accession)
- The Data frame was created from phenoData which stores Run accesion ,scientific name ,Ftp address and treatments.
- Dataframe contains the following information.
```{r}
phenodata = read.csv('PRJNA432861_phenodata')
print.data.frame(phenodata)
```
<br/><br/>

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create sample folder and Download data from "ftp.sra.ebi.ac.uk".
- Each experiment will have 3 conditions each with 3 replicates, for a total of 9 samples.
- Column Fastq_ftp and sample_alias were binded with function "cbind" and stores in a vector.
- For loop was used to iterate over the vector object.

```{r,eval=FALSE}
system('mkdir samples')
download_file = cbind(as.character(phenodata$fastq_ftp),as.character(phenodata$sample_alias))
for (i in download_file) {
  x = paste('wget -P samples ',i)
  system(x)
}
```


## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Download Genome.
- New folder was created to store Genome information of *Glycine max*.
- The wget command allows you to download files from the Internet using terminal.
- The FTP link of genome is takken from "http://plants.ensembl.org/index.html" which stores complete/partial nucleotide sequence of plant       genome in FASTA format.
```{r,eval=FALSE}
setwd("/home/bif/src/")
system("mkdir genome")
setwd("/home/bif/src/genome")
system("wget  ftp://ftp.ensemblgenomes.org/pub/plants/release-44/fasta/glycine_max/dna/Glycine_max.Glycine_max_v2.1.dna.toplevel.fa.gz")
system('gunzip /home/bif/src/genome/Glycine_max.Glycine_max_v2.1.dna.toplevel.fa.gz')
system('export PATH="/home/bif/src/hisat2-2.1.0/:$PATH"')
```

```{r}
system('ls genome')
```


## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Download gene annotation as  GFF(gene-finding format).
- New folder "gene" was created to store complete gene annotation information of *Glycine max*.
- Downloaded annotation from  **ftp://ftp.ensemblgenomes.org.**
```{r,eval=FALSE}
setwd("/home/bif/src")
system("mkdir genes")
system("wget -P genes ftp://ftp.ensemblgenomes.org/pub/plants/release-44/gff3/glycine_max/Glycine_max.Glycine_max_v2.1.44.gff3.gz")
system('gunzip /home/bif/src/genes/Glycine_max.Glycine_max_v2.1.44.gff3.gz')
```

```{r}
system('ls genes')
```

# &nbsp;&nbsp;&nbsp;&nbsp; 3.3 Index the genome for fast alignemnt and processing.
- Indices allow the aligner to narrow down the potential origin of a query sequence within the genome, saving both time and memory.
- A list.function was applied on genome .fasta file, these functions produce a character vector of the file names.
- Folder name 'index' was created to store the indexed genome.
-  hisat2-build tool was used for indexing.
```{r,eval=FALSE}
genome_name = list.files('genome/') # list file name in the 'genome' folder

genome_address=paste("genome/",genome_name,sep="")

genome_index_name =sub('\\.dna.toplevel.fa$', '', genome_name)

system("mkdir indexes")

genome_index_address = paste("indexes/",genome_index_name,sep='')

str_genome_command = paste("hisat2-2.1.0/hisat2-build -p 8 ",genome_address,genome_index_address) # Building index of the Genome.

system(str_genome_command)

genome_annotation_name = list.files('genes/')

genome_annotation_address = paste('genes/',genome_annotation_name,sep = '') 

splice_site = paste('hisat2-2.1.0/extract_splice_sites.py ','genes/',genome_annotation_name, ">",'indexes/',genome_index_name,'.ss',sep="")
system(splice_site)

exons = paste('hisat2-2.1.0/extract_exons.py ','genes/',genome_annotation_name, ">",'indexes/',genome_index_name,'.exon',sep="")
system(exons)

```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Show Exon information.
```{r}
system("head -6 indexes/*.exon")
```
## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Show splice site information.

```{r}
system("head -6 indexes/*.ss")

```

# &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.4 Quality control of raw data.
- Check data quality using Fastqc tool.
- FastQC ensure that there are no hidden problems which might be more difficult to detect at a later stage.
- Random .fastQ is loaded from samples folder for quality check and stored in new folder named "Before_quality_control".
```{r,eval=FALSE}
random_file = paste('samples/',sample(list.files("samples"),1),sep ='')
system('mkdir Before_quality_control')
output_directory = 'Before_quality_control'
random_fastqc = paste("FastQC/fastqc ",random_file," -o ",output_directory)
system(random_fastqc)
```

##  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FastQC report before trimming and quality control.
- htmltools has includeHTMl function which takes character vector as an input having pattern="html".
- Visualize fastQc results

```{r,eval=FALSE}
target_file = list.files('Before_quality_control',pattern = ".html")
show_path = paste('Before_quality_control/',target_file,sep = '')
htmltools::includeHTML(show_path)
```

##  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Qulaity control of reads : Install TrimGalore
- Trim Galore can remove sequences if they become too short during the trimming process.
- Adapter sequence which used in next generation sequencing or high-throughput sequencing to be trimmed because they affects the               mapping. 
```{r,eval=FALSE}
system('wget http://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.11.5.zip')
system('unzip fastqc_v0.11.5.zip') 
#system('chmod 755 fastqc') 
system('gksudo ln -s /home/master/FastQC/fastqc /usr/bin/')

system('curl -fsSL https://github.com/FelixKrueger/TrimGalore/archive/0.6.0.tar.gz -o trim_galore.tar.gz')
system('tar xvzf trim_galore.tar.gz')
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Run TrimGalore on all samples.
- For loop was used for iterative trimming of samples available in "samples" folder.
- Trimmed samples were stored in folder named "samples_trimmed".
```{r,eval=FALSE}
system('mkdir samples_trimmed')
for (i in 1:dim(phenodata)[1]) {
  x = paste('TrimGalore-0.6.0/trim_galore --gzip --length 20 --max_n 1 -o samples_trimmed --cores 6 --quality 20 --phred33 --paired ', 'samples/',basename(as.character(phenodata['fastq_ftp'][i,])),' ','samples/',basename(as.character(phenodata['sample_alias'][i,])),sep='')
  system(x)
}
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Run FastQC on trimmed samples.
- New folder After_quality_control is made and the fastQC reports of trimmed sample store in this folder.
- Random file in vector random_file which is .fastQ format is picked and under go through FastQC.
- paste converts its arguments to character strings, and concatenates them (separating them by the string given by sep).
```{r,eval=FALSE}
random_file = paste('samples_trimmed/',sample(list.files("samples_trimmed"),1),sep ='')
system('mkdir After_quality_control')
output_directory = 'After_quality_control'
random_fastqc = paste("FastQC/fastqc ",random_file," -o ",output_directory)
system(random_fastqc)
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fastq qulaity report after trimming.

```{r, echo=FALSE,eval=FALSE}
target_file = list.files('After_quality_control',pattern = ".html")
show_path = paste('After_quality_control/',target_file,sep = '')
htmltools::includeHTML(show_path)
```

# &nbsp;&nbsp;&nbsp;&nbsp; 3.5 Mapping transcriptome data to genome.
- Two new directories named "map" and "map_summary" were created to store results and mapping summaries respectively.
- All files of pattern=".fq.gz" in folder "sample_trimmed" were listed using list.files function and stored into a vector.
- Now one by one .fastQ file is call from trimmed sample to map with the index of the refrence genome done with hisat2-build.
- By using 'paste' function data in the vector were concantenated with command line parameters and stored into a charcter vector x.
- By using loops each element in the character vector iterated over system() command.
- Alignments in SAM format were stored in "map" folder. 
- Mapping summary were stored in "map_summary" folder. Each summary file contains information about mapping statistics.  

```{r,eval=FALSE}
system('mkdir map')
system('mkdir map_summary')
all_fastq_files = list.files('samples_trimmed/',pattern = '.fq.gz')
for (i in 1:dim(phenodata)[1]) {
  x = paste('hisat2-2.1.0/hisat2 -p 8 --dta -x ',genome_index_address,' -1 ','samples_trimmed/',sub('\\.fastq.gz$', '',basename(as.character(phenodata['fastq_ftp'][i,]))),'_val_1.fq.gz',' -2 ','samples_trimmed/',sub('\\.fastq.gz$', '',basename(as.character(phenodata['sample_alias'][i,]))),'_val_2.fq.gz', ' -S ',' map/',phenodata['run_accession'][i,],'.sam ','--summary-file  ','map_summary/',phenodata['run_accession'][i,],'.summary',sep='')
  system(x)
  
}

```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Convert SAM format to binary: BAM format.
- All files of pattern =".sam" were listed and stored in a vector all_sam_files.
- Using samtools SAM format was converted in to BAM format.
```{r,eval=FALSE}
all_sam_files = list.files('map/',pattern = '.sam')

for (i in all_sam_files) {
  x = paste('~/src/samtools-1.9/samtools  sort -@ 8 -o map/',sub('\\.sam$','',i),'.bam',' ','map/',i,sep='')
  system(x)
  remove_sam = paste('rm ', 'map/',i,sep = '')
  system(remove_sam)
}
```

```{r}
system('ls ~/src/map_summary')
```

# &nbsp;&nbsp;&nbsp;&nbsp; 3.6 Assemble genes and transcript.
- A new folder named "assembly" was created to stores the results of stringtie performed on the ".bam" files.
- A vector named 'all_bam_files' was created using list.files() function.
- Stringtie was performed on each element of the vector.
- Assembled transcripts produced were stored in "assembly" folder in ".gtf" format.

```{r,eval=FALSE}
system('mkdir assembly')
all_bam_files = list.files('map/',pattern = '.bam')
for (i in 1:length(all_bam_files)){
  x = paste('stringtie-1.3.6.Linux_x86_64/stringtie map/', all_bam_files[i],' -l ',sub('\\.bam$','',all_bam_files[i]),' -p 8 -G ',genome_annotation_address,' -o   ','assembly/',sub('\\.bam$','',all_bam_files[i]),'.gtf',sep='')
  system(x)
}
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Following files were generated by the assembly step.


```{r}
system('ls ~/src/assembly')
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Merge transcripts 
- All ".gtf" file names were listed and their addresses were stored into a vector named 'gtf_file_address'.
```{r,eval=FALSE}
all_gtf_files = list.files('assembly/',pattern = '.gtf')
for (i in all_gtf_files) {
  gtf_file_address = paste('assembly/',i,sep='')
  write.table(gtf_file_address, file="merge_gtf_list.txt", append=TRUE,row.names = FALSE ,sep = '',col.names = FALSE, quote = FALSE) 
}

```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Combines and reformat annotation data to GFF.
```{r}
system('stringtie-1.3.6.Linux_x86_64/stringtie --merge -p 8 -o stringtie_merged.gtf merge_gtf_list.txt')
```
##  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Reading GFF using readGFF
- The combined GFF files contains following informtion.
 
```{r}
merged_gtf_files = readGFF('stringtie_merged.gtf')
head(merged_gtf_files[c(1,3,4,5,9,10,11)],3)
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compare Annotation.
- The program gffcompare was used to compare newly generated GFF file to reference annotation available in public domain.
```{r,eval=FALSE}
system(paste('gffcompare/gffcompare -r ',genome_annotation_address,' ','-G -o ','merged ', 'stringtie_merged.gtf',sep = ''))

merged.annotated.gtf = readGFF('merged.annotated.gtf')

head((merged.annotated.gtf[c(1,3,4,5,9,11,13)]),3)
```

<br/><br/>

# &nbsp;&nbsp;&nbsp;&nbsp; 3.7 Meta analysis of RNAseq assembled data.
- transcriptomic data had been undergone through many programs generating new data.
- The following methods were used to access meta data of transcript and genome.


## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ballgown format
- Ballgown, a software package designed to facilitate differential expression analysis of RNA-seq data.
- A new folder was created named "ballgown', which stores result of stringtie perform on the file 'stringtie_merged.gtf' with the elements of vector named 'all_bam_files vector'.

```{r,eval=FALSE}
system('mkdir ballgown')

for (i in 1:length(all_bam_files)){
  x = paste('stringtie-1.3.6.Linux_x86_64/stringtie -e -B -p 8 -G ','stringtie_merged.gtf -o ballgown/',sub('\\.bam$','',all_bam_files[i]),'/',sub('\\.bam$','',all_bam_files[i]),'.gtf',' map/',sub('\\.bam$','',all_bam_files[i]),'.bam',sep='')
  system(x)
}

```
## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Run ballgown toll to integrate and analyse transcriptome data.
- Ballgown function was supplied with sample pattern and phenodata.
- An object was created which stores the various functional results in nested format.
- Ballgown object had 7 slots which can be accessed using "@". Variables in each slot were accessed using "$" sign.

```{r}
library(ballgown)

all_bg_data <- ballgown(dataDir = "ballgown",
                    samplePattern = "SRR",
                    pData = phenodata)
```


## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Access transcripts from ballgown object
```{r}
tail(all_bg_data@expr$trans[c(2,3,4,5,6,7,8)]) 
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Access chromosome name.
- By using seqnames function. 
```{r}
seqnames(all_bg_data)
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Methods available for ballgown object
- Following methods were available for ballgown object.
```{r}
methods(class="ballgown")
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Access gene names

```{r}
geneNames = geneNames(all_bg_data)
head(geneNames[1:3])
```

<br></br>
<br></br>
<br></br>
<br></br>

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Access transcript information.
```{r}
head(as.data.frame(texpr(all_bg_data))[1:4], 3)
```
## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Retrive expression level of transcripts.

```{r}
head(as.data.frame(eexpr(all_bg_data))[1:4], 3)
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Highly expressed transcripts (filtered by expression level)
- Highly expressed transcripts were retrived using subset method.

```{r}
high_expression_transcripts_filtered = subset(all_bg_data, "rowVars(texpr(all_bg_data)) >0.15", genomesubset=TRUE)
high_expression_transcripts_filtered 
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Transcript differntial expression and map transcript id to transcript name.
- 
```{r}
results_transcripts <- stattest(high_expression_transcripts_filtered,
                                feature=c("transcript"),
                                covariate="treatment",
                               getFC=FALSE, meas="FPKM")

results_transcripts <- data.frame(transcriptNames = transcriptNames(high_expression_transcripts_filtered),
                                  transcriptIDs = transcriptIDs(high_expression_transcripts_filtered),
                                  results_transcripts)
significant_result = results_transcripts %>% filter(qval < 0.05)

print.data.frame(head(significant_result))
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Distribution of transcript counts per gene.
- following code were used to access the information about transcripts per gene.
```{r}
transcript_gene_table = indexes(all_bg_data)$t2g
counts=table(transcript_gene_table[,"g_id"])
c_one = length(which(counts == 1))
c_more_than_one = length(which(counts > 1))
c_max = max(counts)
```

```{r}
{hist(counts, breaks=50, col="bisque4", xlab="Transcripts per gene", main="Distribution of transcript count per gene")
legend_text = c(paste("Genes with one transcript =", c_one), paste("Genes with more than one transcript =", c_more_than_one), paste("Maximum transcripts for a single gene = ", c_max))
legend("topright", legend_text, lty=NULL)}
```

# &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Distribution of transcripts length
- texpr Extract Transcript-Level Expression Measurements From Ballgown Objects
- all_bg_data is ballgown object, texpr data is assign to full_table object.

```{r}
full_table <- texpr(all_bg_data , 'all')
hist(full_table$length, breaks=50, xlab="Transcript length (bp)", main="Distribution of transcript lengths", col="steelblue")
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Distribution of FPKMs for all condition
- Following code was used to  visualize distribution of transcript expression.
```{r}
gene_expression = as.data.frame(gexpr(all_bg_data))
data_columns <- c(4,5,9,1,2,3,6,7,8)
short_names=c("Control_1","Control_2","Control_3","24h_1","24h_2","24h_3","4h_1","4hr_2","4hr_3")
data_colors=c('#893131','#893131','#893131','#1E7679','#1E7679','#1E7679','#E6E6E6','#E6E6E6','#E6E6E6')
min_nonzero=1
boxplot(log2(gene_expression[,data_columns]+min_nonzero), col=data_colors, names=short_names, las=2, ylab="log2(FPKM)", main="Distribution of FPKMs for all condition")
```

# &nbsp;&nbsp;&nbsp;&nbsp; 3.8 HMM modeling on retrived transcripts.
- Following code were used to create HMM modeling using transcript sequences.
## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Retrive transcripts. 
- Transcript sequence from the GTF file were retrived using bedtools.
```{r,eval=FALSE}
system('bedtools getfasta -fi genome/Hordeum_vulgare.IBSC_v2.dna.toplevel.fa -bed merged.annotated.gtf -fo transcript.fasta')

```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Transdecoder
- Coding region within the transcripts were retrived using "transcript.fasta" as input to Transdecoder. mRNA sequences of same were translated in to protei sequences.

```{r,eval=FALSE}
system('./TransDecoder-TransDecoder-v5.5.0/TransDecoder.LongOrfs  -t transcript.fasta')
# Run on terminal if problem occured with command "./TransDecoder-TransDecoder-v5.5.0/TransDecoder.LongOrfs  -t ~/src/transcript.fasta" in src folder.
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Multiple Sequence Alignment.
- All fasta files were converted in to one multifasta file.
```{r}
system('cat dreb/bif_DREB_gene/*.fasta > combinedfasta.fasta')
```
## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Read fastQ files.
- concantenated fasta file read by using readAAStringSet function over the combined.fasta file and assign o dreb_sequences object.
```{r}
dreb_sequences  <- readAAStringSet('combinedfasta.fasta')
head(dreb_sequences)
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Multiple Sequence Alignment
- Multiple sequence alignment algorithms 'ClustalOmega' was used for MSA.
```{r,eval=FALSE}
drebAlignment <- msa(dreb_sequences,"ClustalOmega")
print(drebAlignment)
Aln2 <- msaConvert(drebAlignment, type="seqinr::alignment")
write.msa(Aln2, file='dreb_msa.fasta',format= "FASTA",pretty.print=FALSE)
```
## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Download and install HMMER
```{r,eval=FALSE}
  uncompress hmmer-3.2.tar.gz  
   tar xf hmmer-3.2.tar
   cd hmmer-3.2
   ./configure
   make
   make check
   make install  
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Build a HMM model using MSA output
```{r,eval=FALSE}
system('mkdir HMM')
system('hmmer-3.2/src/hmmbuild HMM/dreb_gmax.hmm dreb_msa.fasta')
```


## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Search HMM model over Proteins derive from the transcripts

```{r,eval=FALSE}
system('mkdir Result')
system('hmmer-3.2/src/hmmsearch --noali -E  0.0001 --cpu 5 --tblout Result/hit.table HMM/dreb_gmax.hmm  transcript.fasta.transdecoder_dir/longest_orfs.pep  > Result/Result.out')
```

##  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create Coordinate table.
- Following method was used to retrived chromosome locations hit by Hmmsearch.

```{r}
hit_location = read.table('Result/hit.table',header = F)$V1
result_1 = c()
result_2 = c()
result_3 = c()
j = 1
for(i in hit_location){
  str=strsplit(i,'.p')[[1]][1]
  result_1[j] <- strsplit(str,':')[[1]][1]
  result_3[j] <- strsplit(str,"-")[[1]][2]
  result_2[j] <- strsplit(strsplit(str,':')[[1]][2],'-')[[1]][1]
  j = j+1
  }
result <- data.frame('seqid'=result_1,'start'=as.numeric(result_2),'end'=as.numeric(result_3),stringsAsFactors=FALSE)
result$start <- result$start+1
print.data.frame(head(result),3)
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create a Genomic range object from coordinate table: result.
```{r}
Grange_object = makeGRangesFromDataFrame(result,
                         keep.extra.columns=FALSE,
                         ignore.strand=FALSE,
                         seqinfo=NULL,
                         seqnames.field=c("seqid"),
                         start.field="start",
                         end.field=c("end"),
                         starts.in.df.are.0based=FALSE)
```


## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GffcompareCreate a compare table using output of 'Gffcompare'
```{r}
merged.annotated.gtf = readGFF('merged.annotated.gtf')
reference_gtf = as.data.frame(cbind('seqid'=as.vector(merged.annotated.gtf$seqid),'start' = merged.annotated.gtf$start,'end'=merged.annotated.gtf$end,'transcript_id'=merged.annotated.gtf$transcript_id,'gene_name'=merged.annotated.gtf$gene_name),stringsAsFactors=FALSE)
str(reference_gtf)
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compare result with reference GTF
```{r}
all_homolog = merge(result,merged.annotated.gtf,by.x = intersect(names(result), names(merged.annotated.gtf)),all.x=TRUE)
all_homolog_filtered = all_homolog[all_homolog$type=='transcript',]
Genes_found = length(unique(all_homolog_filtered$gene_id))
cat('Total no. of homologus genes expressed is',Genes_found)
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Correlation plot between sample to check the consistency visually.

```{r}
transcript_expression <- texpr(all_bg_data)
min_nonzero=1
x = transcript_expression[,"FPKM.SRR6669441"]
y = transcript_expression[,"FPKM.SRR6669442"]
{plot(x=log2(x+min_nonzero), y=log2(y+min_nonzero), pch=16, col="blue", cex=0.25, xlab="FPKM (SRR6669441,Salinity_24h_replicate_2)", ylab="FPKM (SRR6669441, Salinity_24h_replicate_2)", main="Comparison of expression values for a pair of replicates")
abline(a=0,b=1)
rs=cor(x,y)^2
legend("topleft", paste("R squared = ", round(rs, digits=3), sep=""), lwd=1, col="black")}
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Total no. of transcripts originated from Dreb homolouge.

```{r}
indices <- match(all_homolog_filtered$gene_id,rownames(texpr(all_bg_data)))
gene_names_for_result <- texpr(all_bg_data, 'all')$gene_name[indices]
results_genes <- data.frame(geneNames=gene_names_for_result, all_homolog_filtered)
x = all_homolog_filtered$gene_id
all_dreb_transcripts <- merged.annotated.gtf[merged.annotated.gtf$gene_id %in% x, ]
all_dreb_transcripts = all_dreb_transcripts[all_dreb_transcripts$type=='transcript',]
cat('Total no. of transcripts produced by REb family:- expressed + not_expressed     ',dim(all_dreb_transcripts)[1])
```



# &nbsp;&nbsp;&nbsp;&nbsp; 3.9 Statistical testing for transcript expressed in different condition.

- results_transcripts is a data frame which store transcript-level differential analysis.
```{r}
#feature=c("gene", "exon", "intron", "transcript")
results_transcripts <- stattest(all_bg_data,
                                feature=c("transcript"),
                                covariate="treatment",
                               getFC=FALSE, meas="FPKM")

results_transcripts <- data.frame(transcriptNames = transcriptNames(all_bg_data),
                                  transcriptIDs = transcriptIDs(all_bg_data),
                                  results_transcripts)
significant_result = results_transcripts %>% filter(qval < 0.05)

print.data.frame(head(significant_result))
```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Differentially expressed DREB transcripts in the experiment.

```{r}
x = all_homolog_filtered$transcript_id
Differential_expressed_transcripts <- significant_result[significant_result$transcriptNames %in% x, ]
cat('Total no. of transcripts differentially expressed in experiment  is   ',dim(Differential_expressed_transcripts)[1])

```

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bind differentially expressed Dreb transcripts to gene name.
```{r}
x = Differential_expressed_transcripts$transcriptIDs
differential_expressed_transcripts_geneName <- merged.annotated.gtf[merged.annotated.gtf$transcript_id  %in% x, ]
differential_expressed_transcripts_geneName=differential_expressed_transcripts_geneName[differential_expressed_transcripts_geneName$type=='transcript',]
head(differential_expressed_transcripts_geneName)
```
## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Transcript structure.

```{r}

{plotLatentTranscripts(gene='MSTRG.505', gown=all_bg_data, k=2,method='kmeans', returncluster=FALSE)}



```
- Following code were used to calculate the statistical significance of differential expresiion between the conditions.

```{r}
fisher_exact_test <- function(control,treatment){
  A <- matrix(c(control,treatment), ncol=1, byrow=TRUE)
  n <- length(A)  #no. of sample
  m <- length(treatment) ## treatment 
  perms <- chooseMatrix(length(A),length(treatment)) ## finding no. of permutation to assign the treatment in 70*8 matrix (8 total no. of )
  treatment_avg <- (1/4)*perms%*%A
  control_avg <- (1/4)*(1-perms)%*%A
  test_statistic <- abs(treatment_avg-control_avg)
  rownumber <- apply(apply(perms, 1,function(x) (x == c(rep(0,length(control)),rep(1,length(treatment))))), 2, sum)
  rownumber <- (rownumber == length(A))
  observed_test <- test_statistic[rownumber == TRUE]
  larger_than_observed <- (test_statistic >= observed_test)
  sum(larger_than_observed)
  fisher_exact_p_value <- round(sum(larger_than_observed)/choose(length(A),length(treatment)),10)
  No_of_control <- length(control)
  No_of_treatment <- length(treatment)
  a <- data.frame(No_of_control,No_of_treatment,fisher_exact_p_value)
  return(a)
  }
```

```{r}
fisher_exact_test(try$Initial.weight,try$Final.weight)
```
